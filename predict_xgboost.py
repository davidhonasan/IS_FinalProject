import xgboost as xgb
import pandas as pd
import matplotlib.pyplot as plt
from pandas_datareader import data
from sklearn.metrics import r2_score, mean_squared_error
import yfinance as yf
from math import sqrt
yf.pdr_override() 

# Disable XGBoost 0.9.0 Deprecated Warning 
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

def stock_predict(symbol):
  df = data.get_data_yahoo(symbol)

  #Load the data from a csv file.
  stock = {"stock_name":symbol, "data": df}
  stock["data"] = stock["data"].drop(df.columns[4], axis=1)

  Predictors = pd.DataFrame({"sma2":stock["data"].Close.rolling(window=2).mean()})
  Predictors["sma2_1"] = Predictors.sma2.shift(1)

  Predictors["sma2_increment"] = Predictors.sma2.diff()  

  Predictors["sma2_1_increment"] = Predictors.sma2_1.diff()  

  Predictors["vol_increment"] = stock["data"].Volume.diff()

  Predictors["vol_rel_increment"] = stock["data"].Volume.diff() / stock["data"].Volume

  Predictors["close_1"] = stock["data"].Close.shift(1)

  Predictors["close_incr"] = stock["data"].Close - stock["data"].Close.shift(1)

  Predictors["close"] = stock["data"].Close

  # The rows with nulls generated by rolling values will be removed.
  Predictors = Predictors.dropna()

  X = Predictors
  y = X['close_incr']

  train_samples = int(X.shape[0] * 0.75)

  X_train = X.iloc[:train_samples]
  X_test = X.iloc[train_samples:]

  y_train = y.iloc[:train_samples]
  y_test = y.iloc[train_samples:]

  # and the transformation is applied on the test data for later use.
  # The train data will be transformed while it is being fit.
  regressor = xgb.XGBRegressor(objective='reg:squarederror', learning_rate=0.05)
  xgbModel = regressor.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_test, y_test)],
              eval_metric='rmse')
  y_predicted = xgbModel.predict(X_test)

  X_test = X_test.drop(X_test.columns[[0,1,2,3,4,5,6,7]], axis=1)
  X_test['prediction'] = float("NaN")
  X_test['prediction'].iloc[0] = X_test['close'].iloc[0] + y_predicted[0]

  for x in range(len(X_test)-1):
      X_test['prediction'].iloc[x+1] = X_test['prediction'].iloc[x] + y_predicted[x+1] 

  print("RMSE:", sqrt(mean_squared_error(y_test, y_predicted)))
  print("R2 Score:", r2_score(y_test, y_predicted))

  plt.subplot(2,1,1)
  plt.plot(X_train['close'], label="Train")
  plt.plot(X_test['close'], label="Test")
  plt.plot(X_test['prediction'], label="Prediction")
  plt.title(symbol + ' | Acc: ' + str(r2_score(y_test, y_predicted)*100) + '%' )
  plt.legend()
  plt.xlabel("Year")
  plt.ylabel("Close Price ($)")

  plt.subplot(2,1,2)
  plt.plot(xgbModel.evals_result()['validation_0']['rmse'], label="Train")
  plt.plot(xgbModel.evals_result()['validation_1']['rmse'], label="Test")
  plt.legend()
  plt.xlabel("Tree nodes")
  plt.ylabel("RMSE")
  # fig = plt.figure(figsize=(8,8))
  # plt.xticks(rotation='vertical')
  # print(xgbModel.feature_importances_)
  # plt.subplot(3,1,3)
  # plt.bar([i for i in range(len(xgbModel.feature_importances_))], xgbModel.feature_importances_.tolist(), tick_label=X_train.columns, color="chocolate")
  plt.show()

if __name__ == "__main__":
  stock_predict("MSFT")
  stock_predict("AAPL")
  stock_predict("NFLX")
  stock_predict("TSLA")
  stock_predict("FB")